<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hikari&#39;s Blog</title>
  
  
  <link href="https://eternalhikari.github.io/atom.xml" rel="self"/>
  
  <link href="https://eternalhikari.github.io/"/>
  <updated>2020-05-08T08:58:13.016Z</updated>
  <id>https://eternalhikari.github.io/</id>
  
  <author>
    <name>Hikari</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Welcome to Hikari&#39;s Blog</title>
    <link href="https://eternalhikari.github.io/2099/04/13/Welcome-to-Hikari-s-Blog/"/>
    <id>https://eternalhikari.github.io/2099/04/13/Welcome-to-Hikari-s-Blog/</id>
    <published>2099-04-13T08:54:43.000Z</published>
    <updated>2020-05-08T08:58:13.016Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Windows安全事件ID</title>
    <link href="https://eternalhikari.github.io/2021/07/18/Windows%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6ID/"/>
    <id>https://eternalhikari.github.io/2021/07/18/Windows%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6ID/</id>
    <published>2021-07-18T14:54:42.000Z</published>
    <updated>2021-07-18T15:27:33.010Z</updated>
    
    <content type="html"><![CDATA[<h4 id="审计帐户登录事件"><a href="#审计帐户登录事件" class="headerlink" title="审计帐户登录事件"></a>审计帐户登录事件</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4776 </span>– 域控制器试图验证帐户凭证信息<br><span class="hljs-symbol">4777 </span>– 域控制器未能验证帐户凭证信息<br><span class="hljs-symbol">4768 </span>– 要求有Kerberos验证票(TGT)<br><span class="hljs-symbol">4769 </span>– 要求有Kerberos验证票(TGT)<br><span class="hljs-symbol">4770 </span>– Kerberos服务票被更新<br></code></pre></td></tr></table></figure><h4 id="审计帐户管理"><a href="#审计帐户管理" class="headerlink" title="审计帐户管理"></a>审计帐户管理</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4741 </span>– 计算机帐户已创建<br><span class="hljs-symbol">4742 </span>– 计算机帐户已更改<br><span class="hljs-symbol">4743 </span>– 计算机帐户已删除<br><span class="hljs-symbol">4739 </span>– 域政策已经更改<br><span class="hljs-symbol">4782 </span>– 密码hash帐户被访问<br><span class="hljs-symbol">4727 </span>– 安全全局组已经创建<br><span class="hljs-symbol">4728 </span>– 一名用户被添加到安全全局组<br><span class="hljs-symbol">4729 </span>– 一名用户从安全全局组解除<br><span class="hljs-symbol">4730 </span>– 安全全局组已经删除<br><span class="hljs-symbol">4731 </span>– 安全本地组已经创建<br><span class="hljs-symbol">4732 </span>– 一名用户被添加到安全本地组<br><span class="hljs-symbol">4733 </span>– 一名用户被安全本地组解除<br><span class="hljs-symbol">4734 </span>– 安全本地组已经删除<br><span class="hljs-symbol">4735 </span>– 安全本地组已经更改<br><span class="hljs-symbol">4737 </span>– 安全全局组已经更改<br><span class="hljs-symbol">4754 </span>– 安全通用组已创建<br><span class="hljs-symbol">4755 </span>– 安全通用组已创建更改<br><span class="hljs-symbol">4756 </span>– 一名用户被添加到安全通用组<br><span class="hljs-symbol">4757 </span>– 一名用户被安全通用组解除<br><span class="hljs-symbol">4758 </span>– 安全本地组已经删除<br><span class="hljs-symbol">4720 </span>– 用户帐户已创建<br><span class="hljs-symbol">4722 </span>– 用户帐户已启用<br><span class="hljs-symbol">4723 </span>– 试图更改帐户密码<br><span class="hljs-symbol">4724 </span>– 试图重置帐户密码<br><span class="hljs-symbol">4725 </span>– 用户帐户被停用<br><span class="hljs-symbol">4726 </span>– 用户帐户已删除<br><span class="hljs-symbol">4738 </span>– 用户帐户已被改变<br><span class="hljs-symbol">4740 </span>– 用户帐户被锁定<br><span class="hljs-symbol">4765 </span>– SID历史记录被添加到一个帐户<br><span class="hljs-symbol">4766 </span>– 尝试添加SID历史记录到帐户失败<br><span class="hljs-symbol">4767 </span>– 用户帐户被解锁<br><span class="hljs-symbol">4780 </span>– 对管理组成员的帐户设置了ACL<br><span class="hljs-symbol">4781 </span>– 帐户名称已经更改 <br></code></pre></td></tr></table></figure><h4 id="审计目录服务访问"><a href="#审计目录服务访问" class="headerlink" title="审计目录服务访问"></a>审计目录服务访问</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4934 </span>– Active Directory 对象的属性被复制<br><span class="hljs-symbol">4935 </span>– 复制失败开始<br><span class="hljs-symbol">4936 </span>– 复制失败结束<br><span class="hljs-symbol">5136 </span>– 目录服务对象已修改<br><span class="hljs-symbol">5137 </span>– 目录服务对象已创建<br><span class="hljs-symbol">5138 </span>– 目录服务对象已删除<br><span class="hljs-symbol">5139 </span>– 目录服务对象已经移动<br><span class="hljs-symbol">5141 </span>– 目录服务对象已删除<br><span class="hljs-symbol">4932 </span>– 命名上下文的AD的副本同步已经开始<br><span class="hljs-symbol">4933 </span>– 命名上下文的AD的副本同步已经结束<br></code></pre></td></tr></table></figure><h4 id="审计登录事件"><a href="#审计登录事件" class="headerlink" title="审计登录事件"></a>审计登录事件</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4634 </span>– 帐户被注销<br><span class="hljs-symbol">4647 </span>– 用户发起注销<br><span class="hljs-symbol">4624 </span>– 帐户已成功登录<br><span class="hljs-symbol">4625 </span>– 帐户登录失败<br><span class="hljs-symbol">4648 </span>– 试图使用明确的凭证登录<br><span class="hljs-symbol">4675 </span>– SID被过滤<br><span class="hljs-symbol">4649 </span>– 发现重放攻击<br><span class="hljs-symbol">4778 </span>– 会话被重新连接到<span class="hljs-keyword">Window</span> Station<br><span class="hljs-symbol">4779 </span>– 会话断开连接到<span class="hljs-keyword">Window</span> Station<br><span class="hljs-symbol">4800 </span>– 工作站被锁定<br><span class="hljs-symbol">4801 </span>– 工作站被解锁<br><span class="hljs-symbol">4802 </span>– 屏幕保护程序启用<br><span class="hljs-symbol">4803 </span>– 屏幕保护程序被禁用<br><span class="hljs-symbol">5378 </span>– 所要求的凭证代表是政策所不允许的<br><span class="hljs-symbol">5632 </span>– 要求对无线网络进行验证<br><span class="hljs-symbol">5633 </span>– 要求对有线网络进行验证<br></code></pre></td></tr></table></figure><h4 id="审计对象访问"><a href="#审计对象访问" class="headerlink" title="审计对象访问"></a>审计对象访问</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5140 </span>– 网络共享对象被访问<br><span class="hljs-symbol">4664 </span>– 试图创建一个硬链接<br><span class="hljs-symbol">4985 </span>– 交易状态已经改变<br><span class="hljs-symbol">5051 </span>– 文件已被虚拟化<br><span class="hljs-symbol">5031 </span>– Windows防火墙服务阻止一个应用程序接收网络中的入站连接<br><span class="hljs-symbol">4698 </span>– 计划任务已创建<br><span class="hljs-symbol">4699 </span>– 计划任务已删除<br><span class="hljs-symbol">4700 </span>– 计划任务已启用<br><span class="hljs-symbol">4701 </span>– 计划任务已停用<br><span class="hljs-symbol">4702 </span>– 计划任务已更新<br><span class="hljs-symbol">4657 </span>– 注册表值被修改<br><span class="hljs-symbol">5039 </span>– 注册表项被虚拟化<br><span class="hljs-symbol">4660 </span>– 对象已删除<br><span class="hljs-symbol">4663 </span>– 试图访问一个对象<br></code></pre></td></tr></table></figure><h4 id="审计政策变化"><a href="#审计政策变化" class="headerlink" title="审计政策变化"></a>审计政策变化</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4715 </span>– 对象上的审计政策(SACL)已经更改<br><span class="hljs-symbol">4719 </span>– 系统审计政策已经更改<br><span class="hljs-symbol">4902 </span>– Per– user审核政策表已经创建<br><span class="hljs-symbol">4906 </span>– CrashOnAuditFail值已经变化<br><span class="hljs-symbol">4907 </span>– 对象的审计设置已经更改<br><span class="hljs-symbol">4706 </span>– 创建到域的新信任<br><span class="hljs-symbol">4707 </span>– 到域的信任已经删除<br><span class="hljs-symbol">4713 </span>– Kerberos政策已更改<br><span class="hljs-symbol">4716 </span>– 信任域信息已经修改<br><span class="hljs-symbol">4717 </span>– 系统安全访问授予帐户<br><span class="hljs-symbol">4718 </span>– 系统安全访问从帐户移除<br><span class="hljs-symbol">4864 </span>– 名字空间碰撞被删除<br><span class="hljs-symbol">4865 </span>– 信任森林信息条目已添加<br><span class="hljs-symbol">4866 </span>– 信任森林信息条目已删除<br><span class="hljs-symbol">4867 </span>– 信任森林信息条目已取消<br><span class="hljs-symbol">4704 </span>– 用户权限已分配<br><span class="hljs-symbol">4705 </span>– 用户权限已移除<br><span class="hljs-symbol">4714 </span>– 加密数据复原政策已取消<br><span class="hljs-symbol">4944 </span>– 当开启Windows Firewall时下列政策启用<br><span class="hljs-symbol">4945 </span>– 当开启Windows Firewall时列入一个规则<br><span class="hljs-symbol">4946 </span>– 对Windows防火墙例外列表进行了修改，添加规则<br><span class="hljs-symbol">4947 </span>– 对Windows防火墙例外列表进行了修改，规则已修改<br><span class="hljs-symbol">4948 </span>– 对Windows防火墙例外列表进行了修改，规则已删除<br><span class="hljs-symbol">4949 </span>– Windows防火墙设置已恢复到默认值<br><span class="hljs-symbol">4950 </span>– Windows防火墙设置已更改<br><span class="hljs-symbol">4951 </span>– 因为主要版本号码不被Windows防火墙承认，规则已被忽视<br><span class="hljs-symbol">4952 </span>– 因为主要版本号码不被Windows防火墙承认，部分规则已被忽视，将执行规则的其余部分<br><span class="hljs-symbol">4953 </span>– 因为Windows防火墙不能解析规则，规则被忽略<br><span class="hljs-symbol">4954 </span>– Windows防火墙组政策设置已经更改，将使用新设置<br><span class="hljs-symbol">4956 </span>– Windows防火墙已经更改主动资料<br><span class="hljs-symbol">4957 </span>– Windows防火墙不适用于以下规则<br><span class="hljs-symbol">4958 </span>– 因为该规则涉及的条目没有被配置，Windows防火墙将不适用以下规则：<br><span class="hljs-symbol">6144 </span>– 组策略对象中的安全政策已经成功运用<br><span class="hljs-symbol">6145 </span>– 当处理组策略对象中的安全政策时发生一个或者多个错误<br><span class="hljs-symbol">4670 </span>– 对象的权限已更改<br></code></pre></td></tr></table></figure><h4 id="审计特权使用"><a href="#审计特权使用" class="headerlink" title="审计特权使用"></a>审计特权使用</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4672 </span>– 给新登录分配特权<br><span class="hljs-symbol">4673 </span>– 要求特权服务<br><span class="hljs-symbol">4674 </span>– 试图对特权对象尝试操作<br></code></pre></td></tr></table></figure><h4 id="审计系统事件"><a href="#审计系统事件" class="headerlink" title="审计系统事件"></a>审计系统事件</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5024 </span>– Windows防火墙服务已成功启动<br><span class="hljs-symbol">5025 </span>– Windows防火墙服务已经被停止<br><span class="hljs-symbol">5027 </span>– Windows防火墙服务无法从本地存储检索安全政策，该服务将继续执行目前的政策<br><span class="hljs-symbol">5028 </span>– Windows防火墙服务无法解析的新的安全政策，这项服务将继续执行目前的政策<br><span class="hljs-symbol">5029 </span>– Windows防火墙服务无法初始化的驱动程序，这项服务将继续执行目前的政策<br><span class="hljs-symbol">5030 </span>– Windows防火墙服务无法启动<br><span class="hljs-symbol">5032 </span>– Windows防火墙无法通知用户它阻止了接收入站连接的应用程序<br><span class="hljs-symbol">5033 </span>– Windows防火墙驱动程序已成功启动<br><span class="hljs-symbol">5034 </span>– Windows防火墙驱动程序已经停止<br><span class="hljs-symbol">5035 </span>– Windows防火墙驱动程序未能启动<br><span class="hljs-symbol">5037 </span>– Windows防火墙驱动程序检测到关键运行错误，终止。<br><span class="hljs-symbol">4608 </span>– Windows正在启动<br><span class="hljs-symbol">4609 </span>– Windows正在关机<br><span class="hljs-symbol">4616 </span>– 系统时间被改变<br><span class="hljs-symbol">4621 </span>– 管理员从CrashOnAuditFail回收系统，非管理员的用户现在可以登录，有些审计活动可能没有被记录<br><span class="hljs-symbol">4697 </span>– 系统中安装服务器<br><span class="hljs-symbol">4618 </span>– 监测安全事件样式已经发生<br></code></pre></td></tr></table></figure><p><a href="http://www.wmksj.com/wzty/56.html">参考链接</a></p><p><strong>官方文档</strong></p><p><a href="https://docs.microsoft.com/zh-cn/windows/security/threat-protection/auditing/event-4625">Windows安全事件ID详细手册</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;审计帐户登录事件&quot;&gt;&lt;a href=&quot;#审计帐户登录事件&quot; class=&quot;headerlink&quot; title=&quot;审计帐户登录事件&quot;&gt;&lt;/a&gt;审计帐户登录事件&lt;/h4&gt;&lt;figure class=&quot;highlight basic&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl</summary>
      
    
    
    
    
    <category term="日志" scheme="https://eternalhikari.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
    <category term="内网" scheme="https://eternalhikari.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>安卓文件格式</title>
    <link href="https://eternalhikari.github.io/2020/12/07/%E5%AE%89%E5%8D%93%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    <id>https://eternalhikari.github.io/2020/12/07/%E5%AE%89%E5%8D%93%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</id>
    <published>2020-12-07T08:42:20.000Z</published>
    <updated>2020-12-11T11:07:52.487Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://wossoneri.github.io/2019/09/12/[Android][Security]Decompile-smali/">http://wossoneri.github.io/2019/09/12/[Android][Security]Decompile-smali/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://wossoneri.github.io/2019/09/12/[Android][Security]Decompile-smali/&quot;&gt;http://wossoneri.github.io/2019/09/12/[Android][Secur</summary>
      
    
    
    
    
    <category term="Android" scheme="https://eternalhikari.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-6447_ES文件浏览器(上)</title>
    <link href="https://eternalhikari.github.io/2020/12/05/CVE-2019-6447_ES%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <id>https://eternalhikari.github.io/2020/12/05/CVE-2019-6447_ES%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%99%A8/</id>
    <published>2020-12-05T13:32:38.000Z</published>
    <updated>2021-07-22T17:16:10.286Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CVE-2019-6447-ES文件浏览器"><a href="#CVE-2019-6447-ES文件浏览器" class="headerlink" title="CVE-2019-6447_ES文件浏览器"></a>CVE-2019-6447_ES文件浏览器</h3><p>​        ES 文件浏览器，是一款基于 Android 系统的多功能手机文件、程序和进程管理器，它支持在手机、电脑、远程和蓝牙间浏览管理文件，在全球有超过亿次的下载量。<br>​        基于 Android 平台的 ES File Explorer File Manager application 4.1.9.7.4 及之前版本中存在安全漏洞，该漏洞源于 ES 应用程序在运行一次之后（CVE-2019-6447），该端口并未关闭依旧可以通过 HTTP 协议 POST 请求接收 JSON 数据，进行解析执行返回结果。攻击者可通过向 TCP 59777 端口发送请求利用该漏洞读取任意文件或执行应用程序。</p><ul><li>ES 文件浏览器在运行时会创建一个绑定在 59777 端口的 HTTP 服务，在该服务提供了 10+ 个命令，用于访问用户手机的数据以及执行应用程序；但该服务并没有对请求进行校验，从而导致出现安全漏洞。</li></ul><blockquote><p>触发条件</p><ul><li>版本 v4.1.9.7.4 或之前(修复该漏洞的版本为 v4.1.9.9 )</li><li>复现设备与手机需处于同一局域网</li></ul></blockquote><h4 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h4><p>版本：v4.1.8.3.1(另外还有v4.1.6.7.2(返回500)，v4.1.9.4(返回400))</p><p>工具：Android killer v1.3.1、dex2jar v2.1、jd-gui v1.6.6 (<a href="https://down.52pojie.cn/Tools/Android_Tools/">爱盘</a>下载即可)</p><p>雷电模拟器 v4.0.27（模拟型号 HUAWEI WLZ-AN00）</p><h4 id="ES文件浏览器工作原理"><a href="#ES文件浏览器工作原理" class="headerlink" title="ES文件浏览器工作原理"></a>ES文件浏览器工作原理</h4><p><a href="https://www.zhihu.com/question/49460056">参考链接</a></p><p>基本原理：使用SMB协议和http服务器来实现</p><p>SMB协议的作用是访问局域网中的共享文件<br>http服务器作用是像我们平时访问网页视频那样，可以在线实时播放局域网视频</p><p><img src="/2020/12/05/CVE-2019-6447_ES%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%99%A8/86808fa060f42a146251e8d8b1fa2540_720w.jpg"></p><p>http服务器在手机里面，电脑和手机在同一个局域网内</p><p>SMB协议：<a href="https://link.zhihu.com/?target=http://baike.baidu.com/link?url=2Ut4IMA5VtkMOlrYzO0bbkvlqvr3i5wIAI-f3Ep-8TGLakXJhdRwSIgI9_CBj85cq8dJTRKbInuxganiXSeqoa">SMB协议_百度百科</a><br>SMB（Server Message Block）通信协议是微软（Microsoft）和英特尔(Intel)在1987年制定的协议，主要是作为<strong>Microsoft网络的通讯协议。</strong>Windows系统就可以使用该协议进行文件传输。但是Android 不支持直接访问局域网的共享文件，所以要用到其它的开源库，来实现文件的访问</p><p>SMB协议和http服务器的实现<br> jcifs 实现smb协议   <a href="https://link.zhihu.com/?target=http://jcifs.samba.org/">http://jcifs.samba.org/</a><br>实现http服务器  <a href="https://link.zhihu.com/?target=https://clinkc.svn.sourceforge.net/svnroot/cgupnpjava/trunk/">https://clinkc.svn.sourceforge.net/svnroot/cgupnpjava/trunk/</a><br>（或者用apache来实现http服务器 ）<a href="https://link.zhihu.com/?target=http://commons.apache.org/proper/commons-net/">Apache Commons Net</a></p><h4 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h4><p>先贴上程序运行的结果</p><p><a href="https://github.com/fs0c131y/ESFileExplorerOpenPortVuln/blob/master/poc.py">POC</a></p><p><img src="/2020/12/05/CVE-2019-6447_ES%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%99%A8/image-20201205175131716.png"></p><p>弹计算器(直接从雷电下载的小牛计算器)</p><p><img src="/2020/12/05/CVE-2019-6447_ES%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%99%A8/ES%E5%BC%B9%E8%AE%A1%E7%AE%97%E5%99%A8.gif"></p><p>当然也可以不使用poc，有一种更优雅的验证方式：<a href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html">curl</a>，来自大佬的<a href="https://www.freebuf.com/vuls/195069.html">文章</a>（是我太菜了555）</p><p><img src="/2020/12/05/CVE-2019-6447_ES%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%99%A8/image-20201210155542106.png"></p><p>在复现过程中，遇到了不同类型的错误(400和500)，专门查了一下错误原因：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">HTTP状态码（HTTP</span> <span class="hljs-string">Status</span> <span class="hljs-string">Code）是用bai以表示网页服务器duHTTP响应状态的3位数字代码。它由</span> <span class="hljs-string">RFC</span> <span class="hljs-number">2616</span> <span class="hljs-string">规范定义的，并得到RFC</span> <span class="hljs-number">2518</span><span class="hljs-string">、RFC</span> <span class="hljs-number">2817</span><span class="hljs-string">、RFC</span> <span class="hljs-number">2295</span><span class="hljs-string">、RFC</span> <span class="hljs-number">2774</span><span class="hljs-string">、RFC</span> <span class="hljs-number">4918</span><span class="hljs-string">等规范扩展。</span><br><span class="hljs-string">表示页面请求的状态值，分别有：</span><br><span class="hljs-number">200</span> <span class="hljs-string">表示请求成功</span><br><span class="hljs-number">303</span> <span class="hljs-string">表示重定向</span><br><span class="hljs-number">400</span> <span class="hljs-string">表示请求错误，服务器不理解请求的语法</span><br><span class="hljs-number">401</span> <span class="hljs-string">表示未授权</span><br><span class="hljs-number">403</span> <span class="hljs-string">表示禁止访问</span><br><span class="hljs-number">404</span> <span class="hljs-string">表示文件未找到</span><br><span class="hljs-number">500</span> <span class="hljs-string">（服务器内部错误），服务器遇到错误，无法完成请求</span><br><span class="hljs-string">更详细的可见https://www.cnblogs.com/buwang/p/9995738.html</span><br></code></pre></td></tr></table></figure><p>由于是第一次复现移动端的CVE，一直不知道问题出在哪里。开始我一直以为是我模拟器的配置问题，或者是poc的py版本不对，但是在网上找大佬的笔记，怎么都不是这样的问题。一拍脑袋，试一下别的ES文件浏览器版本，先是返回500错误变成了400，最终直接用已经证实可以复现的版本，成功复现。</p><p>一开始是用Android killer反编译，确实很好用。拖进去，点一下，啪的一下就出来了，很快啊。</p><p>初步可以看出<strong>工程信息</strong>是大概的文件信息，<strong>工程管理器</strong>是文件的代码结构，具体可见<a href="https://www.cnblogs.com/bingghost/p/5820256.html">这篇博客</a>。再加上上面的工具栏，功能就更多了，以后会不断了解的。挖个坑<a href>Android killer使用</a></p><p><img src="/2020/12/05/CVE-2019-6447_ES%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%99%A8/image-20201207162022315.png"></p><p>根据参考的文章，可以在工程管理器里找到对应的文件路径，但是点开的却是smali文件，如上图。于是我又不得不去查阅了一下安卓的各种文件格式，具体可以看我另一篇文章<a href="%5Bhttps://eternalhikari.github.io/2020/12/07/%E5%AE%89%E5%8D%93%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/%5D(https://eternalhikari.github.io/2020/12/07/%E5%AE%89%E5%8D%93%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/)">安卓文件格式</a>(先挖个坑自己填)。</p><p>在对其他几个版本反编译的时候，出现了<code>AndroidKiller APK 反编译失败</code>的错误提示，在<a href="https://blog.csdn.net/buzul/article/details/108733151">这篇文章</a>找到了解决方式，其实不需要用到后面一个的方式，在<a href="https://www.bilibili.com/read/cv1785046/">这篇文章</a>中提到的<code>Debug</code>工具，执行后会在其目录下的<code>/temp</code>路径出现反编译好的文件(下图为执行成功)，直接将dex文件转为jar文件，再用jd-gui就可查看源码</p><p><img src="/2020/12/05/CVE-2019-6447_ES%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%99%A8/image-20201207163541525.png"></p><p><strong>关键步骤：dex –&gt; jar</strong></p><p>当然也可以直接用android killer直接转</p><p>右键将apk解压到本路径下，在文件夹中可以找到dex文件，利用dex2jar转换为jar文件，并用jd-gui打开。这里我试了linux下执行没能成功，不过直接用windows下的命令也问题不大。</p><p><img src="/2020/12/05/CVE-2019-6447_ES%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%99%A8/image-20201207171714666.png"></p><h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>本次漏洞主要在：<br><code>com.estrongs.fs.impl.adb.c</code><br><code>com.estrongs.android.f.a</code></p><h5 id="com-estrongs-android-f-a"><a href="#com-estrongs-android-f-a" class="headerlink" title="com.estrongs.android.f.a"></a>com.estrongs.android.f.a</h5><p><img src="/2020/12/05/CVE-2019-6447_ES%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%99%A8/image-20201207234919586.png"></p><p>在这个部分可以看到poc一样的内容，是ES浏览器自带的一些获取APP信息的函数，可以利用。我们追踪几个函数看看具体做了些什么</p><ul><li>getDeviceInfo</li></ul><p><img src="/2020/12/05/CVE-2019-6447_ES%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%99%A8/image-20201207235101764.png"></p><p>如果字符串是”getDeviceInfo”，那么会返回b()</p><p><img src="/2020/12/05/CVE-2019-6447_ES%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%99%A8/image-20201207235237719.png"></p><p>可以看出每个函数(不知道对不对，晚点再补一下java的知识)都有类似的结构，若request state code是200，则返回ok，若是400，500则有对应的错误处理机制</p><ul><li>appLaunch</li></ul><p><img src="/2020/12/05/CVE-2019-6447_ES%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%99%A8/image-20201208003745090.png"></p><p>同样，查找a()，和查询设备信息同样的结构</p><p><img src="/2020/12/05/CVE-2019-6447_ES%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%99%A8/image-20201208004056085.png"></p><p>传入<code>appPackageName</code>，从而打开app</p><p>其他功能也大同小异</p><h5 id="com-estrongs-fs-impl-adb-c"><a href="#com-estrongs-fs-impl-adb-c" class="headerlink" title="com.estrongs.fs.impl.adb.c"></a>com.estrongs.fs.impl.adb.c</h5><p><img src="/2020/12/05/CVE-2019-6447_ES%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%99%A8/image-20201208114622611.png"></p><p><img src="/2020/12/05/CVE-2019-6447_ES%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%99%A8/image-20201208114645130.png"></p><p>关键字符串<code>59777</code>一共出现了三次，分别对应查找是如何利用59777端口的</p><p>根据函数参数类型查找对应的函数</p><p><img src="/2020/12/05/CVE-2019-6447_ES%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%99%A8/image-20201211135215829.png"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">boolean</span> a(<span class="hljs-built_in">String</span> paramString, int paramInt1, int paramInt2)<br>&#123;<br>  <span class="hljs-built_in">boolean</span> bool2 = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">for</span> (;;)<br>  &#123;<br>    int i = paramInt2 - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">boolean</span> bool1 = bool2;<br>    <span class="hljs-keyword">if</span> (paramInt2 &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (b(paramString, paramInt1)) &#123;<br>        bool1 = <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> bool1;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (e) &#123;<br>      com.estrongs.android.util.k.b(a, <span class="hljs-string">&quot;adb list try count &quot;</span> + i);<br>    &#125;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>      Thread.sleep(200L);<br>      paramInt2 = i;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Exception localException)<br>    &#123;<br>      localException.printStackTrace();<br>      paramInt2 = i;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/12/05/CVE-2019-6447_ES%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%99%A8/image-20201211135516318.png"></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-keyword">String</span> paramString, <span class="hljs-keyword">int</span> paramInt)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">try</span><br>  &#123;<br>    Socket localSocket = <span class="hljs-keyword">new</span> Socket();<br>    localSocket.<span class="hljs-built_in">connect</span>(<span class="hljs-keyword">new</span> InetSocketAddress(paramString, paramInt), <span class="hljs-number">2000</span>);<br>    localSocket.<span class="hljs-built_in">close</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">catch</span> (Throwable paramString) &#123;&#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>adb</li></ul><p>Android Debug Bridge (adb) 是一个android开发人员必会的多功能的调试工具，如它的名字一样，它在开发者和目标机器之间，架起了一座bridge。<a href="http://blog.sina.com.cn/s/blog_4cd5d2bb0101a1bb.html">参考链接</a></p><h4 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h4><p>用到了<code>TraceReader</code>等工具</p><p><a href="https://www.androiddevtools.cn/">https://www.androiddevtools.cn/</a></p><p><a href="https://www.sohu.com/a/250396062_741445">https://www.sohu.com/a/250396062_741445</a></p><p>参考链接：</p><p><a href="https://www.freebuf.com/vuls/195069.html">https://www.freebuf.com/vuls/195069.html</a></p><p><a href="https://blog.csdn.net/weixin_34248705/article/details/92250456">https://blog.csdn.net/weixin_34248705/article/details/92250456</a></p><p>参考文章：</p><p><a href="https://www.52pojie.cn/thread-856993-1-1.html">https://www.52pojie.cn/thread-856993-1-1.html</a></p><p><a href="https://github.com/fs0c131y/ESFileExplorerOpenPortVuln">https://github.com/fs0c131y/ESFileExplorerOpenPortVuln</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;CVE-2019-6447-ES文件浏览器&quot;&gt;&lt;a href=&quot;#CVE-2019-6447-ES文件浏览器&quot; class=&quot;headerlink&quot; title=&quot;CVE-2019-6447_ES文件浏览器&quot;&gt;&lt;/a&gt;CVE-2019-6447_ES文件浏览器&lt;/</summary>
      
    
    
    
    
    <category term="CVE" scheme="https://eternalhikari.github.io/tags/CVE/"/>
    
    <category term="Android" scheme="https://eternalhikari.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>浏览器时序图&amp;参考架构</title>
    <link href="https://eternalhikari.github.io/2020/12/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE&amp;%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/"/>
    <id>https://eternalhikari.github.io/2020/12/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE&amp;%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/</id>
    <published>2020-12-01T09:59:22.000Z</published>
    <updated>2020-12-11T11:07:26.722Z</updated>
    
    <content type="html"><![CDATA[<p>作业要求：</p><p><img src="/2020/12/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE&%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/image-20201104211723313.png"></p><hr><h3 id="一、针对一款典型浏览器，绘制浏览器处理时序图"><a href="#一、针对一款典型浏览器，绘制浏览器处理时序图" class="headerlink" title="一、针对一款典型浏览器，绘制浏览器处理时序图"></a>一、针对一款典型浏览器，绘制浏览器处理时序图</h3><!--由于平时用chrome比较多，而且上课所讲的内容和web大作业都选择了chrome，故选择chrome来做第一问。--><p>一开始没什么头绪，参考了<a href="https://blog.csdn.net/u013648063/article/details/105459517">一位学长的博客</a>，聊了聊发现还是所里的学长hhh</p><ul><li>先简单梳理一下整个网页加载过程</li></ul><p>首先使用chrome的performance工具，我在这里访问了<a href="https://www.baidu.com/s?ie=UTF-8&amp;wd=hao123">https://www.baidu.com/s?ie=UTF-8&amp;wd=hao123</a></p><p><img src="/2020/12/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE&%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/image-20201201101820354.png"></p><p>从点击到显示完整网页的大概时间如下</p><p><img src="/2020/12/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE&%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/image-20201201102402821.png"></p><p>查看其call tree内容</p><p><img src="/2020/12/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE&%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/image-20201201102452439.png"></p><p>梳理一下浏览器的渲染流程(下图出自霍老师课件)</p><p><img src="/2020/12/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE&%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/image-20201201103251527.png"></p><p>渲染引擎是浏览器的核心部分，渲染引擎解析 HTML 文档，并将各标记逐个转化成 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据，完成HTML布局。Parser是入口点</p><ul><li><p>DOM是文档对象模型(Document Object Model)的缩写，标准由 W3C 组织指定。</p><p>DOM树是把 HTML 文档呈现为带有元素、属性和文本的树结构。DOM引擎解析HTML、XML、SVG、MathML、XUL等内容。</p></li><li><p>Render树</p><p>包含若干带有颜色、面积等可视化属性的矩形。也就是我们学前端时的各个div的布局(从左往右、从上到下)</p></li><li><p>CSS解释器</p><p>解析CSS，为DOM中的各个元素计算样式信息。</p></li><li><p>脚本引擎</p><p>包括JavaScript、VBScript、asm.js、WebAssembly等解释器，对脚本进行解释执行，并对DOM、CSS进行修改。</p></li></ul><p>下图为chrome浏览器的执行流程，出自<a href="https://zhuanlan.zhihu.com/p/27628685">认识 V8 引擎(下文也有引用)</a>，这个图更好地说明了网页从加载内容到显示需要经过的流程</p><p><img src="/2020/12/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE&%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/v2-ad0a86d3faf223164a9bd22658feadc3_720w.png"></p><h4 id="1-对用户界面进行拖拽操作"><a href="#1-对用户界面进行拖拽操作" class="headerlink" title="1. 对用户界面进行拖拽操作"></a>1. 对用户界面进行拖拽操作</h4><p>前面操作同上，下图可以看出我是拖拽窗口了(下图为gif)</p><p><img src="/2020/12/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE&%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/%E6%8B%96%E6%8B%BD.gif"></p><p>call tree显示如下：</p><p><img src="/2020/12/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE&%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/image-20201201110932131.png"></p><p>从Call Tree可以看出对浏览器拖拽窗口主要有如下7个活动：</p><ul><li>Update Layer Tree：更新页面树</li><li>Paint ：重新绘制</li><li>Layout： 页面布局计算执行时触发</li><li>Event：resize：发生了拉伸窗口事件</li><li>Time Fired：定时器激活回调后触发</li><li>Composite Layers： Chrome的渲染引擎完成图片层合并时触发</li><li>Hit Test：这是跟踪指针下的对象的过程，移动屏幕上的container时会产生</li></ul><p>用Event Log来分析，可知拉伸窗口这个动作并没有使chrome向网络栈请求资源，涉及到的只有内核部分的渲染，具体过程即上述活动依次进行</p><p><img src="/2020/12/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE&%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/image-20201201113208573.png"></p><p>用plantUML画图，代码如下。(作图地址：<a href="https://www.planttext.com/">https://www.planttext.com/</a>)</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">@startuml<br>title Chrome Browser Timeline<br><br>participant Skia <span class="hljs-keyword">order</span> <span class="hljs-title">8</span><br>participant GDI <span class="hljs-keyword">order</span> <span class="hljs-title">7</span><br>participant V8 <span class="hljs-keyword">order</span> <span class="hljs-title">6</span><br>participant Blink <span class="hljs-keyword">order</span> <span class="hljs-title">5</span><br>participant Network_Stack <span class="hljs-keyword">order</span> <span class="hljs-title">4</span><br>participant Browser <span class="hljs-keyword">order</span> <span class="hljs-title">3</span><br>participant UI <span class="hljs-keyword">order</span> <span class="hljs-title">2</span><br>participant <span class="hljs-keyword">User</span> <span class="hljs-title">order</span> <span class="hljs-number">1</span><br><br><span class="hljs-keyword">User</span> <span class="hljs-title">-&gt; UI</span>: enter url<br>UI -&gt; Browser: make a request<br>Browser -&gt; Blink : recalculate style<br>Blink -&gt; GDI : draw fonts<br>GDI --&gt; Blink:<br>Blink -&gt; Skia : draw images<br>Skia --&gt; Blink:<br>Blink --&gt; Browser:page bitmap<br>Browser --&gt; UI:display bitmap<br>UI --&gt; User:<br>@enduml<br></code></pre></td></tr></table></figure><p>时序图如下：</p><p><img src="/2020/12/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE&%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/%E6%8B%96%E6%8B%BD%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p><h4 id="2-带有JavaScript脚本的HTML文档"><a href="#2-带有JavaScript脚本的HTML文档" class="headerlink" title="2.带有JavaScript脚本的HTML文档"></a>2.带有JavaScript脚本的HTML文档</h4><p>用到js脚本的我首先想到了电商网站，于是我打开了<a href="https://www.jd.com/">京东官网</a></p><p>在Network中可以看到用到了js脚本的基本集中在前几秒</p><p><img src="/2020/12/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE&%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/image-20201201120456683.png"></p><p>查看如下</p><p><img src="/2020/12/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE&%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/image-20201201120615119.png"></p><p>多了一个Evaluate Script的活动，其余流程和上述基本一致。</p><p>学长的博客是这么描述整个流程的，部分可见课件(果然是我太菜了，对v8的了解还是太片面)</p><blockquote><p>加载一个Javascript脚本的HTML流程：</p><ul><li>用户在UI界面输入URL</li><li>UI向浏览器发起请求</li><li>浏览器先去找缓存里找这个页面，如果没有，就去网络栈获取URL</li><li>网络栈返回页面数据</li><li>浏览器将页面数据传给blink渲染引擎拿去渲染</li><li>blink分别依赖GDI、Skia绘制字体，图像</li><li>blink返回给浏览器一个页面bitmap</li><li>浏览器展示bitmap到UI界面上去</li><li>用户观察到页面变化</li></ul></blockquote><p>以下加一些我的补充</p><p><img src="/2020/12/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE&%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/image-20201201163836322.png"></p><p>V8引擎在执行JavaScript的过程中，主要有两个阶段：编译和运行。与C++的执行前完全编译不同的是，JavaScript需要在用户使用时完成编译和执行。在V8中，JavaScript相关代码并非一下完成编译的，而是在某些代码需要执行时，才会进行编译，这就提高了响应时间，减少了时间开销。在V8引擎中，源代码先被解析器转变为抽象语法树(AST)，然后使用JIT编译器的全代码生成器从AST直接生成本地可执行代码。这个过程不同于JAVA先生成字节码或中间表示，减少了AST到字节码的转换时间，提高了代码的执行速度。但由于缺少了转换为字节码这一中间过程，也就减少了优化代码的机会。(优化可以参考<a href="https://zhuanlan.zhihu.com/p/99395691?tdsourcetag=s_pcqq_aiomsg">JIT是如何工作的</a>)</p><p>V8引擎编译本地代码时使用的主要类如下所示：</p><ul><li>Script：表示JavaScript代码，即包含源代码，又包含编译之后生成的本地代码，即是编译入口，又是运行入口；</li><li>Compiler：编译器类，辅组Script类来编译生成代码，调用解释器(Parser)来生成AST和全代码生成器，将AST转变为本地代码；</li><li>AstNode：抽象语法树节点类，是其他所有节点的基类，包含非常多的子类，后面会针对不同的子类生成不同的本地代码；</li><li>AstVisitor：抽象语法树的访问者类，主要用来遍历异构的抽象语法树；</li><li>FullCodeGenerator：AstVisitor类的子类，通过遍历AST来为JavaScript生成本地可执行代码。</li></ul><p>在V8中，函数是一个基本单位，当某个JavaScript函数被调用时，V8会查找该函数是否已经生成本地代码，如果已经生成，则直接调用该函数。否则，V8引擎会生成属于该函数的本地代码。这就节约了时间，减少了处理那些使用不到的代码的时间。其次，执行编译后的代码为JavaScript构建JS对象，这需要Runtime类来辅组创建对象，并需要从Heap类分配内存。再次，借助Runtime类中的辅组函数来完成一些功能，如属性访问等。最后，将不用的空间进行标记清除和垃圾回收。</p><p><img src="/2020/12/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE&%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/v2-993bbf0a46f6feaef5f7b5005aa1aa34_720w.png"></p><p>在V8中，TurboFan 和 Ignition 结合起来共同完成JavaScript的编译</p><p>用plantUML画图，代码如下</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@startuml</span><br>title Chrome Browser Timeline<br>User -&gt; <span class="hljs-attribute">UI</span>: enter url<br>UI -&gt; <span class="hljs-attribute">Browser</span>: make a request<br>Browser -&gt; <span class="hljs-attribute">Network_Stack</span>:obtain a page without cache<br>Network_Stack -&gt; <span class="hljs-attribute">Browser</span>:page data<br>Browser -&gt; <span class="hljs-attribute">Blink </span>: render<br>Blink -&gt; <span class="hljs-attribute">V8 </span>:parse JavaScript scripts<br>V8 --&gt; <span class="hljs-attribute">Blink </span>:<br>Blink -&gt; <span class="hljs-attribute">GDI </span>: draw fonts<br>GDI --&gt; <span class="hljs-attribute">Blink</span>:<br>Blink -&gt; <span class="hljs-attribute">Skia </span>: draw images<br>Skia --&gt; <span class="hljs-attribute">Blink</span>:<br>Blink --&gt; <span class="hljs-attribute">Browser</span>: page bitmap<br>Browser --&gt; <span class="hljs-attribute">UI</span>: display bitmap<br>UI --&gt; <span class="hljs-attribute">User</span>:<br><span class="hljs-variable">@enduml</span><br></code></pre></td></tr></table></figure><p>时序图如下</p><p><img src="/2020/12/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE&%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/JS%E5%8A%A0%E8%BD%BD.png"></p><h3 id="二、Edge浏览器参考架构"><a href="#二、Edge浏览器参考架构" class="headerlink" title="二、Edge浏览器参考架构"></a>二、Edge浏览器参考架构</h3><p>同样在学长的<a href="https://blog.csdn.net/u013648063/article/details/105459477">另一篇博客</a>可以参考思路</p><p>按要求要做一个这样的参考架构(以下几个架构出自霍老师课件)</p><p><img src="/2020/12/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE&%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/image-20201201170157375.png"></p><p>其中chrome、Mozilla和IE架构已给出</p><p><img src="/2020/12/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE&%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/image-20201201170317021.png"></p><p><img src="/2020/12/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE&%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/image-20201201170330342.png"></p><p><img src="/2020/12/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE&%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/image-20201201170350871.png"></p><p>翻阅Microsoft edge的<a href="https://docs.microsoft.com/zh-cn/microsoft-edge/extensions-chromium/developer-guide/port-chrome-extension">官方文档</a>(似乎发现了新大陆)，可知新版edge已经使用了chrome内核</p><p><img src="/2020/12/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE&%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/image-20201201172914177.png"></p><p>打开电脑上的edge，用任务管理器查看进程信息(顺便看了一下chrome和firefox的信息，则不会显示这么仔细，大概是每一个标签页都作为一个完整的进程来看待)</p><p><img src="/2020/12/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE&%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/image-20201201171037786.png"></p><p>其中主页是360导航(别骂了别骂了，没设置过这个浏览器555，就有时候看pdf挺舒服)，然后新建了一个标签页搜索了”hao123”</p><p>查阅相关资料得知，老版本的Edge由<code>MicrosoftEdge.exe</code>和<code>MicrosoftEdgeCP.exe</code>两个进程组成，后来的版本采用UWP架构，其进程主要由<code>RuntimeBroker.exe</code>和其他进程组成。其中<code>RuntimeBroker</code>和一些核心进程为中等完整性级别，其他进程都在<code>AppContainer</code>中以低完整性级别运行。</p><p><code>AppContainer</code>是windows提出的进程隔离机制。通过将应用程序与不需要的资源和其他应用程序隔离，可以最大限度地减少恶意操纵的机会。</p><ul><li>Browser_Broker是broker进程，负责启动C网页，同时执行类似文件保存等高特权动作，以中等完整性级别运行。</li><li>Runtime Broker是以中等完整性级别运行，负责权限管理。</li><li>Chakra JIT Complier是JavaScript的编译器，负责解析和执行Javascript代码。</li><li>User Interface Service顾名思义是提供用户接口服务。</li><li>Background Tab Tool 是标签页工具。</li><li>360导航和hao123_360搜索是我打开的页面。Edge会为每一个标签页创建一个进程，是浏览器sandbox机制的体现。</li><li>Microsoft Edge Mangaer是主要进程，有待进一步分析。</li></ul><p>其实大部分内容是还是和上述chrome的结果相似的</p><p>查看MicrosoftEdgeCP.exe的dll，根据描述，推测:</p><ul><li>EdgeContent.dll是Edge的浏览器引擎</li><li>edgehtml.dll是渲染引擎</li><li>JS解释器：chakra.dll</li><li>XML解释器：xmllite.dll</li><li>网络相关组件包含<ul><li>windows HTTP服务：winhttp.dll</li><li>Win32的Internet扩展：wininet.dll</li><li>Web客户端DLL：Windows.Web.dll</li></ul></li><li>用户界面后端包含<ul><li>Windows DirectUI 引擎：dui70.dll</li><li>Windows Direct User Engine：duser.dll</li><li>DirectX Graphics Infrastructure：dxgi.dll</li></ul></li></ul><p>结合以上信息，可以初步绘制Edge参考架构：</p><p><img src="/2020/12/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE&%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/edge%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作业要求：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/12/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE&amp;%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/image-2020</summary>
      
    
    
    
    
    <category term="浏览器" scheme="https://eternalhikari.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器Fuzz</title>
    <link href="https://eternalhikari.github.io/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8Fuzz/"/>
    <id>https://eternalhikari.github.io/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8Fuzz/</id>
    <published>2020-11-20T06:27:26.000Z</published>
    <updated>2020-12-11T11:34:26.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浏览器fuzz"><a href="#浏览器fuzz" class="headerlink" title="浏览器fuzz"></a>浏览器fuzz</h2><h3 id="一、浏览器部分"><a href="#一、浏览器部分" class="headerlink" title="一、浏览器部分"></a>一、浏览器部分</h3><h4 id="1-1-浏览器结构"><a href="#1-1-浏览器结构" class="headerlink" title="1.1 浏览器结构"></a>1.1 浏览器结构</h4><p><img src="/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8Fuzz/image-20201106154532115.png"></p><p>浏览器一般包括DOM引擎、CSS解释器、脚本引擎、渲染引擎、协议支持、媒体流支持、三方库、数据存储、用户界面等几个部分。</p><ul><li><p>用户界面</p><p>与用户交互、接受用户操作、展现浏览器当前状态。包括地址栏、前进/后退按钮、书签菜单等。</p></li><li><p>浏览器引擎</p><p>是一个可嵌入的组件，提供了查询和操作渲染引擎的高层接口(加载、刷新、后退、错误信息等)，使渲染引擎平台无关， 提高可移植性</p></li><li><p>渲染引擎</p><p>浏览器的核心部分。解析HTML文档和CSS描述；依据CSS，完成HTML布局。渲染引擎根据元素与样式信息，计算大小、位置、布局，渲染解析后的内容。</p></li><li><p>网络</p><p>提供网络相关的功能，如协议解析、网络I/O等。浏览器支持的协议通常包括HTTP、FTP、WebSocket、HTTP/2、QUIC、DNS、mDNS、WebRTC等。浏览器支持的媒体流通常包括JPG、GIF、PNG、WebM、Ogg、AAC、MP3、MP4、FLAC等。</p></li><li><p>JavaScript解释器</p><p>解析并执行JavaScript代码，结果返回给渲染引擎</p></li><li><p>XML解析器</p><p>解析XML文档</p></li><li><p>用户界面后端</p><p>提供绘制、窗口原语和字体等</p></li><li><p>数据存储</p><p>存储书签、Cookie、 缓存等各种数据到硬盘上</p></li></ul><h4 id="1-2-渲染引擎"><a href="#1-2-渲染引擎" class="headerlink" title="1.2 渲染引擎"></a>1.2 渲染引擎</h4><p><strong>这是浏览器的核心部分，渲染引擎解析 HTML 文档，并将各标记逐个转化成 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据，完成HTML布局。</strong></p><ul><li><p>CSS解释器</p><p>解析CSS，为DOM中的各个元素计算样式信息。</p></li><li><p>脚本引擎</p><p>包括JavaScript、VBScript、asm.js、WebAssembly等解释器，对脚本进行解释执行，并对DOM、CSS进行修改。</p></li><li><p>DOM是文档对象模型(Document Object Model)的缩写，标准由 W3C 组织指定。</p><p>DOM树是把 HTML 文档呈现为带有元素、属性和文本的树结构。DOM引擎解析HTML、XML、SVG、MathML、XUL等内容。</p></li><li><p>Render树</p><p>包含若干带有颜色、面积等可视化属性的矩形。也就是我们学前端时的各个div的布局(从左往右、从上到下)</p></li></ul><p><strong>渲染过程</strong></p><p><img src="/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8Fuzz/image-20201120114715656.png"></p><p><strong>DOM树fuzz的流程图</strong></p><p><img src="/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8Fuzz/image-20201120123419951.png"></p><h4 id="1-3-JS引擎"><a href="#1-3-JS引擎" class="headerlink" title="1.3 JS引擎"></a>1.3 JS引擎</h4><p>JavaScript引擎是一个专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器之中。</p><p><strong>JS引擎分类</strong></p><ul><li>V8 (Chrome)</li><li>SpiderMonkey (FireFox)</li><li>ChakraCore (Edge)</li><li>JavaScriptCore (Safari)</li></ul><p><strong>执行流程</strong></p><ul><li>JavaScript源代码被Parser解析成AST</li><li>AST经Interpreter解析成Bytecode后执行</li><li>不断执行Bytecode，收集运行时信息，生成优化后的Bytecode</li></ul><p><img src="/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8Fuzz/image-20201120123536971.png"></p><p><strong>对上图的解释</strong></p><ul><li>Parser:脚本执行的入口点，通常发出自定义bytecode</li><li>Bytecode然后由解释器或JIT编译器解释编译</li><li>执行代码与运行时交互，运行时定义各种数据结构的表示，提供内建函数和对象等等</li><li>回收内存所需的垃圾收集器</li></ul><p>JIT编译器的流程</p><p><img src="/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8Fuzz/image-20201120133428453.png"></p><p>JS是脚本语言，每次执行前会先编译再执行。当系统识别这一块代码经常出现时，就定义为hot code，直接运行编译好的二进制代码。</p><p>具体可以参考<a href="https://zhuanlan.zhihu.com/p/99395691?tdsourcetag=s_pcqq_aiomsg">JavaScript 编译 - JIT (just-in-time) compiler 是怎么工作的</a></p><p><strong>下图为parser先生成抽象语法树(AST)，再由全代码生成汇编语言，箭头指向调用runtime</strong></p><p><img src="/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8Fuzz/image-20201120123952322.png"></p><h4 id="1-4-WebAssembly"><a href="#1-4-WebAssembly" class="headerlink" title="1.4 WebAssembly"></a>1.4 WebAssembly</h4><p>WebAssembly是在Web中引入的低级语言，其目的和Asm.js类似，也是要支持本地代码的运行从而获得媲美原生应用的高性能。</p><p>它是一种二进制语言，但是无法直接在处理器上运行。在运行时，代码被编译为中间字节代码，可以在浏览器内快速转换为机器代码，然后比传统JavaScript更有效地执行。</p><p><img src="/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8Fuzz/image-20201120124235569.png"></p><p>Wasm的设计从如下几个方面考虑来保证Wasm的安全性</p><ul><li>保护用户免受由于无意的错误而导致漏洞的应用程序的侵害</li><li>保护用户免受故意编写为恶意的应用程序的侵害</li><li>为开发人员提供良好的缓解措施</li></ul><p>具体的安全措施有</p><ul><li>Wasm应用程序在沙箱内运行</li><li>Wasm无法对任意地址进行函数调用。Wasm采用对函数进行编号的方式，编号存储在函数表中</li><li>间接函数调用受类型签名检查的约束</li><li>调用堆栈受到保护，这意味着无法覆盖返回指针</li><li>实现了控制流完整性，这意味着调用意外的函数将失败</li></ul><h3 id="二、Fuzz部分"><a href="#二、Fuzz部分" class="headerlink" title="二、Fuzz部分"></a>二、Fuzz部分</h3><p>Fuzz又称模糊测试，是一种侧重于发现软件安全漏洞的方法。</p><p>Fuzz是通过构造非预期的输入数据并监控目标软件在运行过程中的异常结果来发现软件故障。</p><h4 id="2-1-核心功能"><a href="#2-1-核心功能" class="headerlink" title="2.1 核心功能"></a>2.1 核心功能</h4><p><img src="/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8Fuzz/image-20201112202145078.png"></p><h4 id="2-2-基本流程"><a href="#2-2-基本流程" class="headerlink" title="2.2 基本流程"></a>2.2 基本流程</h4><p><img src="/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8Fuzz/image-20201112202215878.png"></p><h4 id="2-3-fuzz分类"><a href="#2-3-fuzz分类" class="headerlink" title="2.3 fuzz分类"></a>2.3 fuzz分类</h4><p>根据fuzz对象可以分为</p><ul><li><p>白盒模糊测试</p></li><li><p>黑盒模糊测试</p></li><li><p>灰盒模糊测试</p></li></ul><p>根据模糊测试的研究类型可分为</p><ul><li>基于变异的fuzz</li><li>基于生成的fuzz</li></ul><p><img src="/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8Fuzz/image-20201120130629044.png"></p><h3 id="三、浏览器fuzz"><a href="#三、浏览器fuzz" class="headerlink" title="三、浏览器fuzz"></a>三、浏览器fuzz</h3><h4 id="3-1-如何进行浏览器fuzz-我们需要关心什么"><a href="#3-1-如何进行浏览器fuzz-我们需要关心什么" class="headerlink" title="3.1 如何进行浏览器fuzz(我们需要关心什么)"></a>3.1 如何进行浏览器fuzz(我们需要关心什么)</h4><p><img src="/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8Fuzz/image-20201120130821904.png"></p><p><strong>主要关心的问题</strong>：如何输入、如何有效输入、可fuzz的地方有哪些</p><p><img src="/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8Fuzz/image-20201120131021057.png"></p><p>以一个例子为例，可知一个通用的方法：</p><ul><li>通过调用接口获取信息</li><li>由参数类型构造数据</li><li>使用监视器监视</li></ul><p>如何构造是个问题</p><p><img src="/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8Fuzz/image-20201120131755791.png"></p><p>这部分与上述提到的JIT编译器有关。既可以输入js源代码，也可以输入bytecode</p><p><img src="/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8Fuzz/image-20201120131814384.png"></p><p>在fuzz中，测试集是很重要的。因为后续的变异是基于初试testcase变异的。</p><p><img src="/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8Fuzz/image-20201120135609995.png"></p><p>这里补充一下fuzz常见的基于的规格：<a href="https://www.freebuf.com/articles/system/197678.html">可以戳这里看第五大点</a></p><ul><li>基于块</li></ul><p>将程序拖入ida会分成一块一块的代码，这些代码会从上到下依次执行，当遇到转移/跳转指令之后到下一个代码块</p><ul><li>基于边</li></ul><p>代码块与块之间的跳转</p><ul><li>基于元组</li></ul><p>基于两个块和中间的边，可以记录前后块的信息，包含一定的前后文的情况</p><p><img src="/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8Fuzz/image-20201120135812935.png"></p><p>基于文法同样可以获得很多满足结构的语法片段。例如1+2+3可以分为(1+2)+3和1+(2+3)，抽象语法树一般有多个满足语法条件的形式。这种方式同样可以生成规模很大的测试集</p><p><img src="/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8Fuzz/image-20201120142001479.png"></p><h4 id="3-2-对浏览器fuzz的分类"><a href="#3-2-对浏览器fuzz的分类" class="headerlink" title="3.2 对浏览器fuzz的分类"></a>3.2 对浏览器fuzz的分类</h4><h5 id="3-2-1-按功能分"><a href="#3-2-1-按功能分" class="headerlink" title="3.2.1 按功能分"></a>3.2.1 按功能分</h5><p>在浏览器中，Fuzz框架要实现的主要功能是随机样本的生成、浏览器进程监控、Crash样本保存。而各个框架则在完成基本功能的基础上实现分布式调度、自定义fuzz策略、样本精简、分析crash等特性。</p><p>如果要分类的话，浏览器fuzz工具大概可以分为框架类、策略类以及综合类。策略类工具制定了一系列新建、修改、删除DOM元素的规则。通过生成随机样本的方式，产生不同的样本来测试浏览器是否产生异常。而框架类工具则是提供了启动并监控浏览器进程、打开或记录异常样本等功能，将策略类工具承载起来的Fuzzing平台。</p><ul><li><p>框架类比较有代表性的是BFuzzer、grinder、cross_fuzz、x-fuzzer等，这类工具提供了fuzz的基本功能，但是没有涉及样本生成的策略。</p></li><li><p>策略类工具中比较有代表性的是nduja和fileja[3-5]，这两个工具是由Valotta完成的浏览器fuzz样本生成脚本，有着比较丰富的生成规则，但是并没有实现自动化的测试等功能。</p></li><li><p>综合类则综合了两类的特点，完成了两种功能，比较有代表性的是clusterfuzz、funfuzz、chromefuzzer、ajaxdemolisher、lithium等。</p></li></ul><p>这些工具基本都通过javascript脚本进行fuzz操作，同时通过hook函数、localStorage本地存储等技术手段动态记录fuzz操作日志，捕获到异常后再根据记录日志进行还原。</p><h5 id="3-2-2-按攻击面分类"><a href="#3-2-2-按攻击面分类" class="headerlink" title="3.2.2 按攻击面分类"></a>3.2.2 按攻击面分类</h5><p>另外一种分类的思路是按攻击面分类，常见的fuzzer都是针对DOM进行fuzz，但是也有一些fuzz工具专注于其他的攻击面。比如针对ActiveX进行fuzz的axman，另外也有一些针对JavaScript脚本、CSS、PDF、SVG、Flash、浏览器扩展、插件等进行fuzz的工具。</p><h5 id="3-2-3-随机样本的生成"><a href="#3-2-3-随机样本的生成" class="headerlink" title="3.2.3 随机样本的生成"></a>3.2.3 随机样本的生成</h5><p>随机样本生成的好坏，直接决定了该工具能否挖掘出有价值的漏洞。目前纯Fuzz方法中，比较流行的就是<strong>根据目标文件格式生成</strong>针对性样本，效果也比较理想。以HTML文档为例，诞生过很多随机生成HTML/DOM元素的Browser Fuzzer。</p><p>曾经盛名一时的nduja，其大致思路就是，利用JavaScript随机创建DOM元素、随机调用DOM处理函数、随机删除DOM元素等操作来完成每一次Fuzz的。</p><h4 id="3-3-样本保存"><a href="#3-3-样本保存" class="headerlink" title="3.3 样本保存"></a>3.3 样本保存</h4><p><img src="/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8Fuzz/image-20201120141743643.png"></p><p>附上一张从bytecode到插桩的流程图</p><h5 id="3-3-1-记录随机数"><a href="#3-3-1-记录随机数" class="headerlink" title="3.3.1 记录随机数"></a>3.3.1 记录随机数</h5><p>结合之前提到的创建DOM元素的方式，一种思路是将本次rand函数生成的所有随机数全部保存下来即可。Grinder框架就是基于这种思路，采用DLL注入的方式，劫持了JavaScript的parseFloat函数，用以记录某次样本需要记录的相关参数。</p><p>但是这样有几个缺点，一个是浏览器最新版本一般不提供symbols文件或发布symbols文件比较慢，这无疑限制了Grinder对最新浏览器的测试能力。另外一个是有时候可能是多个HTML共同导致了某个Crash，但是Grinder的日志只记录了一个HTML中的log信息，可能无法重现该类漏洞。</p><h5 id="3-3-2-记录随机样本"><a href="#3-3-2-记录随机样本" class="headerlink" title="3.3.2 记录随机样本"></a>3.3.2 记录随机样本</h5><p>既然记录随机值的方式存在一定的问题，那么就有了另一个思路，直接将模版中的随机元素生成后进行保存，然后浏览器再访问。这样就简化了从日志中恢复样本的流程，而且更为准确。</p><h5 id="3-3-3-WebSocket通信"><a href="#3-3-3-WebSocket通信" class="headerlink" title="3.3.3 WebSocket通信"></a>3.3.3 WebSocket通信</h5><p>另一个方法是利用websocket，实时的把相关信息发送到服务器，在服务器端进行保存。但是这样也有一个缺点，运行的websocket相关脚本可能也会影响浏览器样本的fuzz情况。</p><h5 id="3-4-4-其他样本生成方式"><a href="#3-4-4-其他样本生成方式" class="headerlink" title="3.4.4 其他样本生成方式"></a>3.4.4 其他样本生成方式</h5><p>另外一种方式是根据已有的HTML样本进行变换之后生成。 样本可以来源于之前的0day，从网上获取的一些样本。 样本构造尽可能多的覆盖HTML的属性，比如css/javascript等</p><h4 id="3-4-浏览器进程监控"><a href="#3-4-浏览器进程监控" class="headerlink" title="3.4 浏览器进程监控"></a>3.4 浏览器进程监控</h4><p>在对浏览器的异常检测上，通常有Pydbg和Windbg等方式，这些方式都各有优劣。但pydbg对python3和x64系统软件支持都不是特别好，另外windbg具有很吸引人的!exploitable插件[2-7]，虽然某些时候给出的结论并不准确，但不失为一种对漏洞可利用性做出预判的方法。</p><p>另一个方法是，在Windows下某个进程崩溃时，通常会弹出WerFault.exe异常提示,可以根据进程列表中有无WerFault.exe作为监控浏览器是否发生Crash的依据。另外，将Windbg的命令行版cdb.exe设置为默认即时调试器。当发生crash时自动调用该调试器，并做下记录，也是一个可行的方法。</p><h4 id="3-5-浏览器fuzz缺点"><a href="#3-5-浏览器fuzz缺点" class="headerlink" title="3.5 浏览器fuzz缺点"></a>3.5 浏览器fuzz缺点</h4><p>很多浏览器fuzz工具每运行一个测试用例都会重启待测浏览器进程，因为浏览器重启在运行一个测试用例过程中耗时占比较大，进而导致fuzz效率不高。</p><h4 id="3-6-别的思考"><a href="#3-6-别的思考" class="headerlink" title="3.6 别的思考"></a>3.6 别的思考</h4><p><img src="/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8Fuzz/image-20201120141854144.png"></p><p>这里需要说一下JS竟用条件<br><strong>所有现代浏览器都使用一条OS线程来实现JS脚本引擎。</strong><br>唯一的例外是web workers,但它不会访问DOM，相对安全风险较小。</p><p><img src="/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8Fuzz/image-20201120142145127.png"></p><p>由于大部分事件是异步处理的，所以很有可能同一事件内不同部件的内存内容不同，这极易引发安全问题。</p><p>附上V8编译概览</p><p><img src="/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8Fuzz/image-20201120142332917.png"></p><blockquote><p>这篇文章是我在web安全大作业的一部分，刘老师真的很赞</p><p>文中截取了一些霍玮老师、刘奇旭老师课件上的图片(说明俺听了2333</p><p>文章也引用了很多交大大佬<a href="https://github.com/LyleMi/Browser-Fuzz-Summarize">LyleMi</a>已经总结好的内容，了解到了许多细节</p><p>感谢队友，尤其是plusls，orz</p><p>在整理过程中，我看了很多相关论文和v8的资料，每一个地方都有太多要学的地方了。v8的内容之后估计还会写到，本文以能解释清楚浏览器fuzz的目的来写，所以v8的部分不是很清楚，以后会结合着真实案例来写。</p><p>如果有什么问题，师傅可以点击[联系我](<a href="mailto:yagami1230@outlook.com">Email</a>)发邮件</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;浏览器fuzz&quot;&gt;&lt;a href=&quot;#浏览器fuzz&quot; class=&quot;headerlink&quot; title=&quot;浏览器fuzz&quot;&gt;&lt;/a&gt;浏览器fuzz&lt;/h2&gt;&lt;h3 id=&quot;一、浏览器部分&quot;&gt;&lt;a href=&quot;#一、浏览器部分&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="Fuzzing" scheme="https://eternalhikari.github.io/tags/Fuzzing/"/>
    
    <category term="Chrome V8" scheme="https://eternalhikari.github.io/tags/Chrome-V8/"/>
    
    <category term="浏览器" scheme="https://eternalhikari.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>用AFL编译开源软件</title>
    <link href="https://eternalhikari.github.io/2020/04/08/%E7%94%A8AFL%E7%BC%96%E8%AF%91%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/"/>
    <id>https://eternalhikari.github.io/2020/04/08/%E7%94%A8AFL%E7%BC%96%E8%AF%91%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/</id>
    <published>2020-04-07T18:46:39.000Z</published>
    <updated>2020-12-11T11:08:13.894Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在开头，附上参考链接"><a href="#写在开头，附上参考链接" class="headerlink" title="写在开头，附上参考链接"></a>写在开头，附上参考链接</h4><p><a href="https://blog.csdn.net/abcdyzhang/article/details/53487683">如何使用AFL进行一次完整的fuzz过程</a></p><ul><li><a href="https://blog.csdn.net/Chen_zju/article/details/80791268">AFL工具分析</a></li><li><a href="https://paper.seebug.org/496/">更多细节</a></li><li><a href="https://mp.weixin.qq.com/s?srcid=1014wog8b1xL7UtYWyAagzpB&scene=23&sharer_sharetime=1571047773348&mid=2458299789&sharer_shareid=70adaa3f6eb7c8e6a71f15f9191436d0&sn=04ab934c33bd2bd361aa5c11ad4e0be1&idx=1&__biz=MjM5NTc2MDYxMw==&chksm=b1819d0786f614114ea12532b7b73806a2526d4c4191f076d66c3d3518becc9207319c2f69d2&mpshare=1#rd">对afl_fuzz.c的详细分析</a></li><li><a href="https://bbs.pediy.com/thread-257399.htm">AFL学习笔记（上）</a></li></ul><p>接上一篇我对AFL的入门实践 <a href="https://eternalhikari.github.io/2020/01/08/AFL%E7%9A%84%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/">AFL的入门学习</a></p><hr><blockquote><p>实验环境</p><p>ubuntu 16.04(虚拟机) 内存分配4gb</p><p>afl 2.52b</p></blockquote><h4 id="以-bento4-为例"><a href="#以-bento4-为例" class="headerlink" title="以 bento4 为例"></a>以 bento4 为例</h4><p>Bento4 is a C++ class library and tools designed to read and write ISO-MP4 files. </p><ul><li>下载<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/axiomatic-systems/</span>Bento4<br></code></pre></td></tr></table></figure></li><li>解压<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> unzip Bento<span class="hljs-number">4</span>-master.zip<br></code></pre></td></tr></table></figure></li><li>新建一个文件夹，并选择编译器</li></ul><p>这里虚拟机记得赋予权限sudo，服务器上为root可能不需要</p><blockquote><ul><li>gcc/g++重新编译目标程序的方法是：</li></ul><p>CC=/path/to/afl/afl-gcc ./configure</p><ul><li>对于一个C++程序，要设置:</li></ul><p>CXX=/path/to/afl/afl-g++</p><p>afl-clang和afl-clang++的使用方法类似</p></blockquote><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dos">sudo <span class="hljs-built_in">mkdir</span> build<br><span class="hljs-built_in">cd</span> build<br>sudo cmake DCMAKE_CXX_COMPILER=afl-g++ ..<br></code></pre></td></tr></table></figure><p>如出现下图则说明编译成功<br><img src="https://img-blog.csdnimg.cn/2020050501275354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGlrYXJp,size_16,color_FFFFFF,t_70" alt="编译开源软件1"></p><ul><li>make编译</li></ul><p>显示下图则说明编译成功，等待片刻即可进行下一步操作<br><img src="https://img-blog.csdnimg.cn/20200505013051796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGlrYXJp,size_16,color_FFFFFF,t_70" alt="编译开源软件2"></p><p><img src="https://img-blog.csdnimg.cn/20200505013353893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGlrYXJp,size_16,color_FFFFFF,t_70" alt="编译开源软件3"><br>此时输入<code>file **</code>即可发现生成的为elf文件</p><ul><li>进行fuzz<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">sudo afl-fuzz -i <span class="hljs-regexp">/your/</span>tesecase -o <span class="hljs-regexp">/your/</span>fuzz_out_file .<span class="hljs-regexp">/elf_file @@ /</span>dev/<span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>这里的测试文件(input)后面不要加路径”/“，输出文件可自动生成</li><li>可以加参数 -m <strong>，</strong>的数字即代表使用多少内存来运行 </li></ul></blockquote></li></ul><p><img src="https://img-blog.csdnimg.cn/20200505015538587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGlrYXJp,size_16,color_FFFFFF,t_70" alt="编译开源软件4"></p><p>这个时间比较漫长，耐心等待即可(一个空的样例基本需要半个小时)。最好在服务器上跑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;写在开头，附上参考链接&quot;&gt;&lt;a href=&quot;#写在开头，附上参考链接&quot; class=&quot;headerlink&quot; title=&quot;写在开头，附上参考链接&quot;&gt;&lt;/a&gt;写在开头，附上参考链接&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/abc</summary>
      
    
    
    
    
    <category term="Fuzzing" scheme="https://eternalhikari.github.io/tags/Fuzzing/"/>
    
  </entry>
  
  <entry>
    <title>gcc、make、cmake的区别</title>
    <link href="https://eternalhikari.github.io/2020/03/20/gcc%E3%80%81make%E3%80%81cmake%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://eternalhikari.github.io/2020/03/20/gcc%E3%80%81make%E3%80%81cmake%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-03-20T13:27:40.000Z</published>
    <updated>2020-12-11T11:08:05.513Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/f930e2826a6a">make和cmake命令的关系和区别</a></p><h3 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h3><p>gcc简单的来说，它就是Linux平台的一个编译器，当然，它还有其它的平台。我们可以使用gcc来编译我们的（Ｃ、Ｃ、Ｏbject－C等等），比如我们这里有一个文件，hello_world.c，它是用来在标准输出打印一行”hello world”程序的源代码，这个时候我们就可以使用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">gcc</span> <span class="hljs-selector-tag">hello_world</span><span class="hljs-selector-class">.c</span><br></code></pre></td></tr></table></figure><p>便可以生成一个a.out的可执行文件。</p><p>可是，我们的程序有时候可能不是一个单一的源文件，当我们的项目是一个很大的工程时，用gcc命令逐个编译，可能一不小心就会出错。类似于shell脚本，就出现了make工具。</p><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>make工具通过调用makefile文件中的命令便可以对大型程序进行编译，而makefile文件中就包含了调用gcc去编译多个源文件的命令。</p><p>但是，很快又出现了一个问题，如果我们的程序是跨平台的，如果换个平台makefile又要重新修改，这会很麻烦，所以就出现了cmake这个工具，通过cmake我们就可以快速创建出不同平台的makefile文件。</p><h3 id="Cmake"><a href="#Cmake" class="headerlink" title="Cmake"></a>Cmake</h3><p>CMake是一种跨平台编译工具，比make更为高级，使用起来要方便得多。CMake主要是编写CMakeLists.txt文件，然后用cmake命令将CMakeLists.txt文件转化为make所需要的makefile文件，最后用make命令编译源码生成可执行程序或共享库（so(shared object)）</p><p>而Cmake又是根据CMakeLists.txt来生成makefile文件。在编写一个大型程序时，首先编写CMakeLists.txt，然后通过cmake命令就可以生成makefile文件，再通过make命令就可以使用这个makefile文件从而生成可执行文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/f930e2826a6a&quot;&gt;make和cmake命令的关系和区别&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;gcc&quot;&gt;&lt;a href=&quot;#gcc&quot; class=&quot;headerlink&quot; title=&quot;gcc&quot;&gt;&lt;/</summary>
      
    
    
    
    
    <category term="Linux" scheme="https://eternalhikari.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>AFL的入门学习</title>
    <link href="https://eternalhikari.github.io/2020/01/08/AFL%E7%9A%84%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>https://eternalhikari.github.io/2020/01/08/AFL%E7%9A%84%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-01-07T18:43:27.000Z</published>
    <updated>2020-12-11T11:08:27.480Z</updated>
    
    <content type="html"><![CDATA[<h4 id="先贴上我参考的教程"><a href="#先贴上我参考的教程" class="headerlink" title="先贴上我参考的教程"></a>先贴上我参考的教程</h4><ul><li><a href="https://www.freebuf.com/articles/system/191543.html">freebuf1</a>、<a href="https://www.freebuf.com/articles/system/197678.html">freebuf2</a></li><li><a href="https://xz.aliyun.com/t/4314#toc-10">先知社区</a></li></ul><hr><blockquote><p>实验环境</p><p>ubuntu 16.04(虚拟机) 内存分配4gb</p><p>afl 2.52b</p></blockquote><h4 id="AFL是什么"><a href="#AFL是什么" class="headerlink" title="AFL是什么"></a>AFL是什么</h4><p>AFL（American Fuzzy Lop）是由安全研究员Michał Zalewski开发的一款基于覆盖引导（Coverage-guided）的模糊测试工具，它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。</p><p>我们可以在<a href="https://lcamtuf.coredump.cx/afl/">官方网站</a>发现更多有用信息</p><h4 id="AFL的工作流程"><a href="#AFL的工作流程" class="headerlink" title="AFL的工作流程"></a>AFL的工作流程</h4><p><img src="https://img-blog.csdnimg.cn/20200423115056946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGlrYXJp,size_16,color_FFFFFF,t_70" alt="afl1"></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf">①从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）；<br><br>②选择一些输入文件，作为初始测试集加入输入队列（queue）；<br><br>③将队列中的文件按一定的策略进行“突变”；<br><br>④如果经过变异文件更新了覆盖范围，则将其保留添加到队列中<span class="hljs-comment">;</span><br><br>⑤上述过程会一直循环进行，期间触发了crash的文件会被记录下来。<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200425113439275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGlrYXJp,size_16,color_FFFFFF,t_70" alt="AFL流程freebuf"></p><h4 id="下载AFL"><a href="#下载AFL" class="headerlink" title="下载AFL"></a>下载AFL</h4><p><a href="https://www.cnblogs.com/wayne-tao/p/11739420.html">下载指引</a></p><ul><li>安装<code>make</code><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">make</span><br>sudo <span class="hljs-built_in">make</span> install<br></code></pre></td></tr></table></figure><a href>gcc、make、cmake的区别</a></li></ul><h4 id="用afl-gcc编译源程序"><a href="#用afl-gcc编译源程序" class="headerlink" title="用afl-gcc编译源程序"></a>用afl-gcc编译源程序</h4><ul><li>先写一个简单的c程序</li></ul><p>我这里就直接照搬了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt; </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt; </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt; </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt; </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt; </span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vuln</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">strlen</span>(str);<br>    <span class="hljs-keyword">if</span>(str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; len == <span class="hljs-number">66</span>)<br>    &#123;<br>        raise(SIGSEGV);<br>        <span class="hljs-comment">//如果输入的字符串的首字符为A并且长度为66，则异常退出</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;F&#x27;</span> &amp;&amp; len == <span class="hljs-number">6</span>)<br>    &#123;<br>        raise(SIGSEGV);<br>        <span class="hljs-comment">//如果输入的字符串的首字符为F并且长度为6，则异常退出</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;it is good!\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">100</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    gets(buf);<span class="hljs-comment">//存在栈溢出漏洞</span><br>    <span class="hljs-built_in">printf</span>(buf);<span class="hljs-comment">//存在格式化字符串漏洞</span><br>    vuln(buf);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将这段代码程序命名为hello.c</p><ul><li>用afl-gcc编译<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">sudo</span> <span class="hljs-selector-tag">afl-gcc</span> <span class="hljs-selector-tag">-g</span> <span class="hljs-selector-tag">-o</span> <span class="hljs-selector-tag">hello</span> <span class="hljs-selector-tag">hello</span><span class="hljs-selector-class">.c</span><br></code></pre></td></tr></table></figure><blockquote><p>同理 c++ 程序用 afl-g++ 编译</p></blockquote><h4 id="对编译好的文件开始fuzz"><a href="#对编译好的文件开始fuzz" class="headerlink" title="对编译好的文件开始fuzz"></a>对编译好的文件开始fuzz</h4><blockquote><ul><li>对那些可以直接从stdin读取输入的目标程序来说，语法如下：</li></ul></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ .<span class="hljs-regexp">/afl-fuzz -i testcase_dir -o findings_dir /</span>path<span class="hljs-regexp">/to/</span>program […params…]<br></code></pre></td></tr></table></figure><blockquote><ul><li>对从文件读取输入的目标程序来说，要用“@@”，语法如下：</li></ul></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ .<span class="hljs-regexp">/afl-fuzz -i testcase_dir -o findings_dir /</span>path<span class="hljs-regexp">/to/</span>program @@<br></code></pre></td></tr></table></figure>这里采用第一种，首先需要一个测试用例集testcase。输出集会自动生成</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">afl-fuzz -i <span class="hljs-regexp">/your_path/</span>testcase -o <span class="hljs-regexp">/your_path/</span>fuzz_out_file ./hello<br></code></pre></td></tr></table></figure><blockquote><p>常见参数及含义</p><ul><li>-f参数表示：testcase的内容会作为afl_test的stdin</li><li>-m参数表示分配的内存空间</li><li>-i 指定测试样本的路径</li><li>-o 指定输出结果的路径</li><li>/dev/null 使错误信息不输出到屏幕</li><li>-t：设置程序运行超时值，单位为 ms</li><li>-M：运行主(Master) Fuzzer</li><li>-S：运行从属(Slave) Fuzzer</li></ul></blockquote><p>在虚拟机上一般会报错，需要根据提示设置一波<code>core_pattern</code>:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo su<br>echo core &gt;<span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>core_pattern<br></code></pre></td></tr></table></figure><p>再次fuzz，即可出现afl界面<br><img src="https://img-blog.csdnimg.cn/20200505021628723.png" alt="hello"></p><h4 id="对afl界面的简单分析"><a href="#对afl界面的简单分析" class="headerlink" title="对afl界面的简单分析"></a>对afl界面的简单分析</h4><ul><li><code>process timing</code></li></ul><p>这里展示了当前fuzzer的运行时间、最近一次发现新执行路径的时间、最近一次崩溃的时间、最近一次超时的时间。</p><p>值得注意的是第2项，最近一次发现新路径的时间。如果由于目标二进制文件或者命令行参数出错，那么其执行路径应该是一直不变的，所以如果从fuzzing开始一直没有发现新的执行路径，那么就要考虑是否有二进制或者命令行参数错误的问题了。对于此状况，AFL也会智能地进行提醒</p><ul><li><code>overall results</code></li></ul><p>这里包括运行的总周期数、总路径数、崩溃次数、超时次数。</p><p>其中，总周期数可以用来作为何时停止fuzzing的参考。随着不断地fuzzing，周期数会不断增大，其颜色也会由洋红色，逐步变为黄色、蓝色、绿色。一般来说，当其变为绿色时，代表可执行的内容已经很少了，继续fuzzing下去也不会有什么新的发现了。此时，我们便可以通过Ctrl-C，中止当前的fuzzing</p><ul><li><code>stage progress</code></li></ul><p>这里包括正在测试的fuzzing策略、进度、目标的执行总次数、目标的执行速度</p><p>执行速度可以直观地反映当前跑的快不快，如果速度过慢，比如低于500次每秒，那么测试时间就会变得非常漫长。如果发生了这种情况，那么我们需要进一步调整优化我们的fuzzing</p><p>以上是简单的介绍，如果要看完整的可以查看<a href="https://lcamtuf.coredump.cx/afl/status_screen.txt">官方文档</a></p><h4 id="分析crash"><a href="#分析crash" class="headerlink" title="分析crash"></a>分析crash</h4><ul><li>打开刚刚创建的fuzz_out文件夹<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/your_path/</span>fuzz_out_file<br></code></pre></td></tr></table></figure></li><li>使用xxd分析漏洞<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">xxd id:<span class="hljs-strong">****</span><span class="hljs-strong">**,sig:**</span>    <span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">**<span class="hljs-emphasis">*</span></span><br></code></pre></td></tr></table></figure>这样就完成了第一次对afl的探索，同样我们可以对开源程序进行fuzz<a href>用AFL编译开源软件</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;先贴上我参考的教程&quot;&gt;&lt;a href=&quot;#先贴上我参考的教程&quot; class=&quot;headerlink&quot; title=&quot;先贴上我参考的教程&quot;&gt;&lt;/a&gt;先贴上我参考的教程&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.freebuf.com/art</summary>
      
    
    
    
    
    <category term="Fuzzing" scheme="https://eternalhikari.github.io/tags/Fuzzing/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://eternalhikari.github.io/2020/01/05/hello-world/"/>
    <id>https://eternalhikari.github.io/2020/01/05/hello-world/</id>
    <published>2020-01-05T05:24:57.101Z</published>
    <updated>2020-05-11T13:38:39.064Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
